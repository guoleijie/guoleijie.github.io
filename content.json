{"meta":{"title":"Just Do IT","subtitle":"重新起航的老码农","description":"重新起航的老码农","author":"GuoLeijie","url":"http://guoleijie.github.io","root":"/"},"pages":[{"title":"categories","date":"2017-10-20T08:19:30.000Z","updated":"2017-11-17T10:44:53.000Z","comments":true,"path":"categories/index.html","permalink":"http://guoleijie.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"Hyperledger-Python打造淘宝","date":"2018-10-15T01:26:59.000Z","updated":"2019-06-03T05:59:23.328Z","comments":true,"path":"2018/10/15/Hyperledger-Python打造淘宝/","link":"","permalink":"http://guoleijie.github.io/2018/10/15/Hyperledger-Python打造淘宝/","excerpt":"","text":"1、Hyperledger Fabric及相关应用程序简介Hyperledger Fabric 是一个开源的区块链框架，可以用来创建私有区块链（许可区块链）业务网络，在网络中每个成员的身份和角色都被其他成员所知。 我们要构建的区块链网络将以 Fabric 作为后端，客户端应用程序作为前端。目前软件开发工具包（SDK）支持使用 Node.js 和 Java 来构建客户端应用程序，未来很快就会支持 Python 和 Golang。 保交所 生成CSR，私钥 to RootCA 1234title: 申请证书保交所-&gt;保交所:生成CSR，私钥保交所-&gt;RootCA:申请证书RootCA-&gt;保交所:返回证书信息 模块：CA证书： key： 证书： 中间证书: AdminCert： 安装合约、创建通道、","categories":[],"tags":[]},{"title":"","slug":"23种设计模式全解析-行为模式","date":"2018-08-08T21:56:27.000Z","updated":"2019-06-03T05:59:53.408Z","comments":true,"path":"2018/08/09/23种设计模式全解析-行为模式/","link":"","permalink":"http://guoleijie.github.io/2018/08/09/23种设计模式全解析-行为模式/","excerpt":"","text":"第三种设计模式——行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 先来张图，看看这11中模式的关系： 第一类：通过父类与子类的关系进行实现。第二类：两个类之间。第三类：类的状态。第四类：通过中间类 ###13、策略模式（strategy） 策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下： 图中ICalculator提供同意的方法，AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类： 首先统一接口： 123public interface ICalculator &#123; public int calculate(String exp);&#125; 辅助类： 12345678910public abstract class AbstractCalculator &#123; public int[] split(String exp,String opt)&#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125;&#125; 三个实现类： 12345678public class Plus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,\"\\\\+\"); return arrayInt[0]+arrayInt[1]; &#125;&#125; 123456789public class Minus extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,\"-\"); return arrayInt[0]-arrayInt[1]; &#125; &#125; 12345678public class Multiply extends AbstractCalculator implements ICalculator &#123; @Override public int calculate(String exp) &#123; int arrayInt[] = split(exp,\"\\\\*\"); return arrayInt[0]*arrayInt[1]; &#125;&#125; 简单的测试类： 123456789public class StrategyTest &#123; public static void main(String[] args) &#123; String exp = \"2+8\"; ICalculator cal = new Plus(); int result = cal.calculate(exp); System.out.println(result); &#125;&#125; 输出：10 策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。 ###14、模板方法模式（Template Method） 解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图： 就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子： 12345678910111213141516171819public abstract class AbstractCalculator &#123; /*主方法，实现对本类其它方法的调用*/ public final int calculate(String exp,String opt)&#123; int array[] = split(exp,opt); return calculate(array[0],array[1]); &#125; /*被子类重写的方法*/ abstract public int calculate(int num1,int num2); public int[] split(String exp,String opt)&#123; String array[] = exp.split(opt); int arrayInt[] = new int[2]; arrayInt[0] = Integer.parseInt(array[0]); arrayInt[1] = Integer.parseInt(array[1]); return arrayInt; &#125;&#125; 1234567public class Plus extends AbstractCalculator &#123; @Override public int calculate(int num1,int num2) &#123; return num1 + num2; &#125;&#125; 测试类： 123456789public class StrategyTest &#123; public static void main(String[] args) &#123; String exp = \"8+8\"; AbstractCalculator cal = new Plus(); int result = cal.calculate(exp, \"\\\\+\"); System.out.println(result); &#125;&#125; 我跟踪下这个小程序的执行过程：首先将exp和”\\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。 ###15、观察者模式（Observer） 包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图： 我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码： 一个Observer接口： 123public interface Observer &#123; public void update();&#125; 两个实现类： 1234567public class Observer1 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer1 has received!\"); &#125;&#125; 12345678public class Observer2 implements Observer &#123; @Override public void update() &#123; System.out.println(\"observer2 has received!\"); &#125; &#125; Subject接口及实现类： 1234567891011121314public interface Subject &#123; /*增加观察者*/ public void add(Observer observer); /*删除观察者*/ public void del(Observer observer); /*通知所有的观察者*/ public void notifyObservers(); /*自身的操作*/ public void operation();&#125; 123456789101112131415161718192021public abstract class AbstractSubject implements Subject &#123; private Vector&lt;Observer&gt; vector = new Vector&lt;Observer&gt;(); @Override public void add(Observer observer) &#123; vector.add(observer); &#125; @Override public void del(Observer observer) &#123; vector.remove(observer); &#125; @Override public void notifyObservers() &#123; Enumeration&lt;Observer&gt; enumo = vector.elements(); while(enumo.hasMoreElements())&#123; enumo.nextElement().update(); &#125; &#125;&#125; 123456789public class MySubject extends AbstractSubject &#123; @Override public void operation() &#123; System.out.println(\"update self!\"); notifyObservers(); &#125; &#125; 测试类： 1234567891011public class ObserverTest &#123; public static void main(String[] args) &#123; Subject sub = new MySubject(); sub.add(new Observer1()); sub.add(new Observer2()); sub.operation(); &#125; &#125; 输出： update self! observer1 has received! observer2 has received! ###16、迭代子模式（Iterator） 顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：","categories":[],"tags":[]},{"title":"","slug":"23种设计模式全解析-结构模式","date":"2018-08-08T21:35:48.000Z","updated":"2019-06-03T05:59:57.676Z","comments":true,"path":"2018/08/09/23种设计模式全解析-结构模式/","link":"","permalink":"http://guoleijie.github.io/2018/08/09/23种设计模式全解析-结构模式/","excerpt":"","text":"###6、适配器模式（Adapter） 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看类的适配器模式，先看类图： 核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码： 123456public class Source &#123; public void method1() &#123; System.out.println(\"this is original method!\"); &#125;&#125; 12345678public interface Targetable &#123; /* 与原类中的方法相同 */ public void method1(); /* 新类的方法 */ public void method2();&#125; 1234567public class Adapter extends Source implements Targetable &#123; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125;&#125; Adapter类继承Source类，实现Targetable接口，下面是测试类： 12345678public class AdapterTest &#123; public static void main(String[] args) &#123; Targetable target = new Adapter(); target.method1(); target.method2(); &#125;&#125; 输出： this is original method! this is the targetable method! 这样Targetable接口的实现类就具有了Source类的功能。 对象的适配器模式 基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图： 只需要修改Adapter类的源码即可： 123456789101112131415161718public class Wrapper implements Targetable &#123; private Source source; public Wrapper(Source source)&#123; super(); this.source = source; &#125; @Override public void method2() &#123; System.out.println(\"this is the targetable method!\"); &#125; @Override public void method1() &#123; source.method1(); &#125;&#125; 测试类： 123456789public class AdapterTest &#123; public static void main(String[] args) &#123; Source source = new Source(); Targetable target = new Wrapper(source); target.method1(); target.method2(); &#125;&#125; 输出与第一种一样，只是适配的方法不同而已。 第三种适配器模式是接口的适配器模式，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图： 这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码： 12345public interface Sourceable &#123; public void method1(); public void method2();&#125; 抽象类Wrapper2： 12345public abstract class Wrapper2 implements Sourceable&#123; public void method1()&#123;&#125; public void method2()&#123;&#125;&#125; 12345public class SourceSub1 extends Wrapper2 &#123; public void method1()&#123; System.out.println(\"the sourceable interface's first Sub1!\"); &#125;&#125; 12345public class SourceSub2 extends Wrapper2 &#123; public void method2()&#123; System.out.println(\"the sourceable interface's second Sub2!\"); &#125;&#125; 123456789101112public class WrapperTest &#123; public static void main(String[] args) &#123; Sourceable source1 = new SourceSub1(); Sourceable source2 = new SourceSub2(); source1.method1(); source1.method2(); source2.method1(); source2.method2(); &#125;&#125; 测试输出： the sourceable interface’s first Sub1! the sourceable interface’s second Sub2! 达到了我们的效果！ 讲了这么多，总结一下三种适配器模式的应用场景： 类的适配器模式：当希望将一个类转换成满足另一个新接口的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。 对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。 接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。 ###7、装饰模式（Decorator） 顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下： Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下： 123public interface Sourceable &#123; public void method();&#125; 1234567public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125;&#125; 123456789101112131415public class Decorator implements Sourceable &#123; private Sourceable source; public Decorator(Sourceable source)&#123; super(); this.source = source; &#125; @Override public void method() &#123; System.out.println(\"before decorator!\"); source.method(); System.out.println(\"after decorator!\"); &#125;&#125; 测试类： 12345678public class DecoratorTest &#123; public static void main(String[] args) &#123; Sourceable source = new Source(); Sourceable obj = new Decorator(source); obj.method(); &#125;&#125; 输出： before decorator! the original method! after decorator! 装饰器模式的应用场景： 1、需要扩展一个类的功能。 2、动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。） 缺点：产生过多相似的对象，不易排错！ ###8、代理模式（Proxy） 其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图： 根据上文的阐述，代理模式就比较容易的理解了，我们看下代码： 123public interface Sourceable &#123; public void method();&#125; 1234567public class Source implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"the original method!\"); &#125;&#125; 1234567891011121314151617181920public class Proxy implements Sourceable &#123; private Source source; public Proxy()&#123; super(); this.source = new Source(); &#125; @Override public void method() &#123; before(); source.method(); atfer(); &#125; private void atfer() &#123; System.out.println(\"after proxy!\"); &#125; private void before() &#123; System.out.println(\"before proxy!\"); &#125;&#125; 测试类： 12345678public class ProxyTest &#123; public static void main(String[] args) &#123; Sourceable source = new Proxy(); source.method(); &#125; &#125; 输出： before proxy! the original method! after proxy! 代理模式的应用场景： 如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 使用代理模式，可以将功能划分的更加清晰，有助于后期维护！ ###9、外观模式（Facade） 外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例） 我们先看下实现类： 12345678910public class CPU &#123; public void startup()&#123; System.out.println(\"cpu startup!\"); &#125; public void shutdown()&#123; System.out.println(\"cpu shutdown!\"); &#125;&#125; 12345678910public class Memory &#123; public void startup()&#123; System.out.println(\"memory startup!\"); &#125; public void shutdown()&#123; System.out.println(\"memory shutdown!\"); &#125;&#125; 12345678910public class Disk &#123; public void startup()&#123; System.out.println(\"disk startup!\"); &#125; public void shutdown()&#123; System.out.println(\"disk shutdown!\"); &#125;&#125; 123456789101112131415161718192021222324252627public class Computer &#123; private CPU cpu; private Memory memory; private Disk disk; public Computer()&#123; cpu = new CPU(); memory = new Memory(); disk = new Disk(); &#125; public void startup()&#123; System.out.println(\"start the computer!\"); cpu.startup(); memory.startup(); disk.startup(); System.out.println(\"start computer finished!\"); &#125; public void shutdown()&#123; System.out.println(\"begin to close the computer!\"); cpu.shutdown(); memory.shutdown(); disk.shutdown(); System.out.println(\"computer closed!\"); &#125;&#125; User类如下： 12345678public class User &#123; public static void main(String[] args) &#123; Computer computer = new Computer(); computer.startup(); computer.shutdown(); &#125;&#125; 输出： start the computer! cpu startup! memory startup! disk startup! start computer finished! begin to close the computer! cpu shutdown! memory shutdown! disk shutdown! computer closed! 如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！ ###10、桥接模式（Bridge） 桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图： 实现代码： 先定义接口： 123public interface Sourceable &#123; public void method();&#125; 分别定义两个实现类： 1234567public class SourceSub1 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the first sub!\"); &#125;&#125; 1234567public class SourceSub2 implements Sourceable &#123; @Override public void method() &#123; System.out.println(\"this is the second sub!\"); &#125;&#125; 定义一个桥，持有Sourceable的一个实例： 123456789101112131415public abstract class Bridge &#123; private Sourceable source; public void method()&#123; source.method(); &#125; public Sourceable getSource() &#123; return source; &#125; public void setSource(Sourceable source) &#123; this.source = source; &#125;&#125; 12345public class MyBridge extends Bridge &#123; public void method()&#123; getSource().method(); &#125;&#125; 测试类： 1234567891011121314151617public class BridgeTest &#123; public static void main(String[] args) &#123; Bridge bridge = new MyBridge(); /*调用第一个对象*/ Sourceable source1 = new SourceSub1(); bridge.setSource(source1); bridge.method(); /*调用第二个对象*/ Sourceable source2 = new SourceSub2(); bridge.setSource(source2); bridge.method(); &#125;&#125; output： this is the first sub! this is the second sub! 这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。 ###11、组合模式（Composite） 组合模式有时又叫部分-整体模式在处理类似树形结构的问题时比较方便，看看关系图： 直接来看代码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class TreeNode &#123; private String name; private TreeNode parent; private Vector&lt;TreeNode&gt; children = new Vector&lt;TreeNode&gt;(); public TreeNode(String name)&#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public TreeNode getParent() &#123; return parent; &#125; public void setParent(TreeNode parent) &#123; this.parent = parent; &#125; //添加孩子节点 public void add(TreeNode node)&#123; children.add(node); &#125; //删除孩子节点 public void remove(TreeNode node)&#123; children.remove(node); &#125; //取得孩子节点 public Enumeration&lt;TreeNode&gt; getChildren()&#123; return children.elements(); &#125;&#125; 123456789101112131415161718public class Tree &#123; TreeNode root = null; public Tree(String name) &#123; root = new TreeNode(name); &#125; public static void main(String[] args) &#123; Tree tree = new Tree(\"A\"); TreeNode nodeB = new TreeNode(\"B\"); TreeNode nodeC = new TreeNode(\"C\"); nodeB.add(nodeC); tree.root.add(nodeB); System.out.println(\"build the tree finished!\"); &#125;&#125; 使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。 ###12、享元模式（Flyweight） 享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。 FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。 看个例子： 看下数据库连接池的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ConnectionPool &#123; private Vector&lt;Connection&gt; pool; /*公有属性*/ private String url = \"jdbc:mysql://localhost:3306/test\"; private String username = \"root\"; private String password = \"root\"; private String driverClassName = \"com.mysql.jdbc.Driver\"; private int poolSize = 100; private static ConnectionPool instance = null; Connection conn = null; /*构造方法，做一些初始化工作*/ private ConnectionPool() &#123; pool = new Vector&lt;Connection&gt;(poolSize); for (int i = 0; i &lt; poolSize; i++) &#123; try &#123; Class.forName(driverClassName); conn = DriverManager.getConnection(url, username, password); pool.add(conn); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /* 返回连接到连接池 */ public synchronized void release() &#123; pool.add(conn); &#125; /* 返回连接池中的一个数据库连接 */ public synchronized Connection getConnection() &#123; if (pool.size() &gt; 0) &#123; Connection conn = pool.get(0); pool.remove(conn); return conn; &#125; else &#123; return null; &#125; &#125;&#125; 通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！本章讲解了7种结构型模式，因为篇幅的问题，剩下的11种行为型模式，我们将另起篇章，敬请读者朋友们持续关注！","categories":[],"tags":[]},{"title":"","slug":"23种设计模式全解析-工厂模式（创建模式）","date":"2018-08-08T21:16:48.000Z","updated":"2019-06-03T06:00:01.649Z","comments":true,"path":"2018/08/09/23种设计模式全解析-工厂模式（创建模式）/","link":"","permalink":"http://guoleijie.github.io/2018/08/09/23种设计模式全解析-工厂模式（创建模式）/","excerpt":"","text":"###1、工厂方法模式（Factory Method） 简单工厂模式模式分为三种： 11、普通工厂模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图： 举例如下：（我们举一个发送邮件和短信的例子） 首先，创建二者的共同接口： 123public interface Sender &#123; public void Send();&#125; 其次，创建实现类： 123456public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is mailsender!\"); &#125;&#125; 1234567public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is sms sender!\"); &#125;&#125; 最后，建工厂类： 12345678910111213public class SendFactory &#123; public Sender produce(String type) &#123; if (\"mail\".equals(type)) &#123; return new MailSender(); &#125; else if (\"sms\".equals(type)) &#123; return new SmsSender(); &#125; else &#123; System.out.println(\"请输入正确的类型!\"); return null; &#125; &#125;&#125; 我们来测试下： 12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produce(\"sms\"); sender.Send(); &#125;&#125; 输出：this is sms sender! 22、多个工厂方法模式，是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图： 将上面的代码做下修改，改动下SendFactory类就行，如下： 12345678910public class SendFactory &#123; public Sender produceMail()&#123; return new MailSender(); &#125; public Sender produceSms()&#123; return new SmsSender(); &#125;&#125; 测试类如下： 12345678public class FactoryTest &#123; public static void main(String[] args) &#123; SendFactory factory = new SendFactory(); Sender sender = factory.produceMail(); sender.Send(); &#125;&#125; 输出：this is mailsender! 33、静态工厂方法模式，将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。 12345678910public class SendFactory &#123; public static Sender produceMail()&#123; return new MailSender(); &#125; public static Sender produceSms()&#123; return new SmsSender(); &#125;&#125; 1234567public class FactoryTest &#123; public static void main(String[] args) &#123; Sender sender = SendFactory.produceMail(); sender.Send(); &#125;&#125; 输出：this is mailsender! 总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。 ###2、抽象工厂模式（Abstract Factory） 工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。 请看例子： 123public interface Sender &#123; public void Send();&#125; 两个实现类： 123456public class MailSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is mailsender!\"); &#125;&#125; 1234567public class SmsSender implements Sender &#123; @Override public void Send() &#123; System.out.println(\"this is sms sender!\"); &#125;&#125; 两个工厂类： 1234567public class SendMailFactory implements Provider &#123; @Override public Sender produce()&#123; return new MailSender(); &#125;&#125; 1234567public class SendSmsFactory implements Provider&#123; @Override public Sender produce() &#123; return new SmsSender(); &#125;&#125; 再提供一个接口： 123public interface Provider &#123; public Sender produce();&#125; 测试类： 12345678public class Test &#123; public static void main(String[] args) &#123; Provider provider = new SendMailFactory(); Sender sender = provider.produce(); sender.Send(); &#125;&#125; 其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！ ###3、单例模式（Singleton） 单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处： 1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。 2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。 3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。 首先我们写一个简单的单例类： 12345678910111213141516171819202122public class Singleton &#123; /* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */ private static Singleton instance = null; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 静态工程方法，创建实例 */ public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return instance; &#125;&#125; 这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下： 123456public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; 但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个： 12345678910public static Singleton getInstance() &#123; if (instance == null) &#123; synchronized (instance) &#123; if (instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125; 似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例： a&gt;A、B线程同时进入了第一个if判断 b&gt;A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton(); c&gt;由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。 d&gt;B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。 e&gt;此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。 所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化： 123456private static class SingletonFactory&#123; private static Singleton instance = new Singleton(); &#125; public static Singleton getInstance()&#123; return SingletonFactory.instance; &#125; 实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式： 123456789101112131415161718192021public class Singleton &#123; /* 私有构造方法，防止被实例化 */ private Singleton() &#123; &#125; /* 此处使用一个内部类来维护单例 */ private static class SingletonFactory &#123; private static Singleton instance = new Singleton(); &#125; /* 获取实例 */ public static Singleton getInstance() &#123; return SingletonFactory.instance; &#125; /* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */ public Object readResolve() &#123; return getInstance(); &#125;&#125; 其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的： 1234567891011121314151617181920public class SingletonTest &#123; private static SingletonTest instance = null; private SingletonTest() &#123; &#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125;&#125; 考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。 补充：采用”影子实例”的办法为单例对象的属性同步更新 123456789101112131415161718192021222324252627282930public class SingletonTest &#123; private static SingletonTest instance = null; private Vector properties = null; public Vector getProperties() &#123; return properties; &#125; private SingletonTest() &#123; &#125; private static synchronized void syncInit() &#123; if (instance == null) &#123; instance = new SingletonTest(); &#125; &#125; public static SingletonTest getInstance() &#123; if (instance == null) &#123; syncInit(); &#125; return instance; &#125; public void updateProperties() &#123; SingletonTest shadow = new SingletonTest(); properties = shadow.getProperties(); &#125;&#125; 通过单例模式的学习告诉我们： 1、单例模式理解起来简单，但是具体实现起来还是有一定的难度。 2、synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。 到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？ 首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的） 其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。 再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。 最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！ ###4、建造者模式（Builder） 工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码： 还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下： 12345678910111213141516public class Builder &#123; private List&lt;Sender&gt; list = new ArrayList&lt;Sender&gt;(); public void produceMailSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new MailSender()); &#125; &#125; public void produceSmsSender(int count)&#123; for(int i=0; i&lt;count; i++)&#123; list.add(new SmsSender()); &#125; &#125;&#125; 测试类： 1234567public class Test &#123; public static void main(String[] args) &#123; Builder builder = new Builder(); builder.produceMailSender(10); &#125;&#125; 从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。 ###5、原型模式（Prototype） 原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类： 1234567public class Prototype implements Cloneable &#123; public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125;&#125; 很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念： 浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。 深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。 此处，写一个深浅复制的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Prototype implements Cloneable, Serializable &#123; private static final long serialVersionUID = 1L; private String string; private SerializableObject obj; /* 浅复制 */ public Object clone() throws CloneNotSupportedException &#123; Prototype proto = (Prototype) super.clone(); return proto; &#125; /* 深复制 */ public Object deepClone() throws IOException, ClassNotFoundException &#123; /* 写入当前对象的二进制流 */ ByteArrayOutputStream bos = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bos); oos.writeObject(this); /* 读出二进制流产生的新对象 */ ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bis); return ois.readObject(); &#125; public String getString() &#123; return string; &#125; public void setString(String string) &#123; this.string = string; &#125; public SerializableObject getObj() &#123; return obj; &#125; public void setObj(SerializableObject obj) &#123; this.obj = obj; &#125; &#125; class SerializableObject implements Serializable &#123; private static final long serialVersionUID = 1L;&#125; 要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。","categories":[],"tags":[]},{"title":"","slug":"23种设计模式全解析-简介","date":"2018-08-08T21:09:56.000Z","updated":"2019-06-03T06:00:18.484Z","comments":true,"path":"2018/08/09/23种设计模式全解析-简介/","link":"","permalink":"http://guoleijie.github.io/2018/08/09/23种设计模式全解析-简介/","excerpt":"","text":"一、设计模式的分类总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下： ##二、设计模式的六大原则 ###总原则：开闭原则（Open Close Principle） 开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。 ###1、单一职责原则 不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。 ###2、里氏替换原则（Liskov Substitution Principle） 里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。 ###3、依赖倒转原则（Dependence Inversion Principle） 这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。 ###4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。 ###5、迪米特法则（最少知道原则）（Demeter Principle） 就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。 最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。 ###6、合成复用原则（Composite Reuse Principle） 原则是尽量首先使用合成/聚合的方式，而不是使用继承。","categories":[],"tags":[]},{"title":"并发系统限流","slug":"并发限流设计","date":"2018-07-26T14:53:00.000Z","updated":"2019-06-03T06:00:14.708Z","comments":true,"path":"2018/07/26/并发限流设计/","link":"","permalink":"http://guoleijie.github.io/2018/07/26/并发限流设计/","excerpt":"","text":"谈谈高并发系统的限流缓存缓存比较好理解，在大型高并发系统中，如果没有缓存数据库将分分钟被爆，系统也会瞬间瘫痪。使用缓存不单单能够提升系统访问速度、提高并发访问量，也是保护数据库、保护系统的有效方式。大型网站一般主要是“读”，缓存的使用很容易被想到。在大型“写”系统中，缓存也常常扮演者非常重要的角色。比如累积一些数据批量写入，内存里面的缓存队列（生产消费），以及HBase写数据的机制等等也都是通过缓存提升系统的吞吐量或者实现系统的保护措施。甚至消息中间件，你也可以认为是一种分布式的数据缓存。 降级服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。 限流限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。 限流的算法常见的限流算法有：计数器、漏桶和令牌桶算法。 计数器计数器是最简单粗暴的算法。比如某个服务最多只能每秒钟处理100个请求。我们可以设置一个1秒钟的滑动窗口，窗口中有10个格子，每个格子100毫秒，每100毫秒移动一次，每次移动都需要记录当前服务请求的次数。内存中需要保存10次的次数。可以用数据结构LinkedList来实现。格子每次移动的时候判断一次，当前访问次数和LinkedList中最后一个相差是否超过100，如果超过就需要限流了。很明显，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.LinkedList;import java.util.Random;import java.util.concurrent.atomic.AtomicLong;public class Counter &#123; /** * 服务访问次数，可以放在Redis中，实现分布式系统的访问计数 */ AtomicLong counter = new AtomicLong(); /** * 使用LinkedList来记录滑动窗口的10个格子。 */ LinkedList&lt;Long&gt; ll = new LinkedList&lt;&gt;(); public static void main(String[] args) &#123; Counter counter = new Counter(); counter.doCheck(); &#125; private void doCheck() &#123; Random random = new Random(); while (true) &#123; //每100毫秒随机增加20以下的请求量 counter.addAndGet(random.nextInt(20)); ll.addLast(counter.longValue()); if (ll.size() &gt; 10) &#123; ll.removeFirst(); &#125; //比较最后一个和第一个，两者相差一秒 System.out.println(\"ll.peekLast():\" + ll.peekLast() + \",ll.peekFirst():\" + ll.peekFirst()); if ((ll.peekLast() - ll.peekFirst()) &gt; 100) &#123; //To limit rate System.out.println(\"进入限流程序\"); &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 漏桶算法漏桶算法即leaky bucket是一种非常常用的限流算法，可以用来实现流量整形（Traffic Shaping）和流量控制（Traffic Policing）。贴了一张维基百科上示意图帮助大家理解： 漏桶算法的主要概念如下： 一个固定容量的漏桶，按照常量固定速率流出水滴； 如果桶是空的，则不需流出水滴； 可以以任意速率流入水滴到漏桶； 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。 漏桶算法比较好实现，在单机系统中可以使用队列来实现（.Net中TPL DataFlow可以较好的处理类似的问题，你可以在这里找到相关的介绍），在分布式环境中消息中间件或者Redis都是可选的方案。 令牌桶算法令牌桶算法是一个存放固定容量令牌（token）的桶，按照固定速率往桶里添加令牌。令牌桶算法基本可以用下面的几个概念来描述： 令牌将按照固定的速率被放入令牌桶中。比如每秒放10个。 桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝。 当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上。 如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。如下图： 令牌算法是根据放令牌的速率去控制输出的速率，也就是上图的to network的速率。to network我们可以理解为消息的处理程序，执行某段业务或者调用某个RPC。 漏桶和令牌桶的比较令牌桶可以在运行时控制和调整数据处理的速率，处理某时的突发流量。放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。而漏桶不行，因为它的流出速率是固定的，程序处理速度也是固定的。 整体而言，令牌桶算法更优，但是实现更为复杂一些。 限流算法实现GuavaGuava是一个Google开源项目，包含了若干被Google的Java项目广泛依赖的核心库，其中的RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。 常规速率： 创建一个限流器，设置每秒放置的令牌数：2个。返回的RateLimiter对象可以保证1秒内不会给超过2个令牌，并且是固定速率的放置。达到平滑输出的效果 1234567891011121314151617public void test()&#123; /** * 创建一个限流器，设置每秒放置的令牌数：2个。速率是每秒可以2个的消息。 * 返回的RateLimiter对象可以保证1秒内不会给超过2个令牌，并且是固定速率的放置。达到平滑输出的效果 */ RateLimiter r = RateLimiter.create(2); while (true) &#123; /** * acquire()获取一个令牌，并且返回这个获取这个令牌所需要的时间。如果桶里没有令牌则等待，直到有令牌。 * acquire(N)可以获取多个令牌。 */ System.out.println(r.acquire()); &#125;&#125; 上面代码执行的结果如下图，基本是0.5秒一个数据。拿到令牌后才能处理数据，达到输出数据或者调用接口的平滑效果。acquire()的返回值是等待令牌的时间，如果需要对某些突发的流量进行处理的话，可以对这个返回值设置一个阈值，根据不同的情况进行处理，比如过期丢弃。 突发流量： 突发流量可以是突发的多，也可以是突发的少。首先来看个突发多的例子。还是上面例子的流量，每秒2个数据令牌。如下代码使用acquire方法，指定参数。 System.out.println(r.acquire(2)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); 得到如下类似的输出。 如果要一次新处理更多的数据，则需要更多的令牌。代码首先获取2个令牌，那么下一个令牌就不是0.5秒之后获得了，还是1秒以后，之后又恢复常规速度。这是一个突发多的例子，如果是突发没有流量，如下代码： System.out.println(r.acquire(1)); Thread.sleep(2000); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); 得到如下类似的结果： 等了两秒钟之后，令牌桶里面就积累了3个令牌，可以连续不花时间的获取出来。处理突发其实也就是在单位时间内输出恒定。这两种方式都是使用的RateLimiter的子类SmoothBursty。另一个子类是SmoothWarmingUp，它提供的有一定缓冲的流量输出方案。 1234567891011121314151617/*** 创建一个限流器，设置每秒放置的令牌数：2个。速率是每秒可以210的消息。* 返回的RateLimiter对象可以保证1秒内不会给超过2个令牌，并且是固定速率的放置。达到平滑输出的效果* 设置缓冲时间为3秒*/RateLimiter r = RateLimiter.create(2,3,TimeUnit.SECONDS);while (true) &#123; /** * acquire()获取一个令牌，并且返回这个获取这个令牌所需要的时间。如果桶里没有令牌则等待，直到有令牌。 * acquire(N)可以获取多个令牌。 */ System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1));&#125; 输出结果如下图，由于设置了缓冲的时间是3秒，令牌桶一开始并不会0.5秒给一个消息，而是形成一个平滑线性下降的坡度，频率越来越高，在3秒钟之内达到原本设置的频率，以后就以固定的频率输出。图中红线圈出来的3次累加起来正好是3秒左右。这种功能适合系统刚启动需要一点时间来“热身”的场景。 ![](并发限流设计/15700-20170501174044882-556744286.png )Nginx对于Nginx接入层限流可以使用Nginx自带了两个模块：连接数限流模块ngx_http_limit_conn_module和漏桶算法实现的请求限流模块ngx_http_limit_req_module。 ngx_http_limit_conn_module 我们经常会遇到这种情况，服务器流量异常，负载过大等等。对于大流量恶意的攻击访问，会带来带宽的浪费，服务器压力，影响业务，往往考虑对同一个ip的连接数，并发数进行限制。ngx_http_limit_conn_module 模块来实现该需求。该模块可以根据定义的键来限制每个键值的连接数，如同一个IP来源的连接数。并不是所有的连接都会被该模块计数，只有那些正在被处理的请求（这些请求的头信息已被完全读入）所在的连接才会被计数。 我们可以在nginx_conf的http{}中加上如下配置实现限制： 1234567#限制每个用户的并发连接数，取名onelimit_conn_zone $binary_remote_addr zone=one:10m;#配置记录被限流后的日志级别，默认error级别limit_conn_log_level error;#配置被限流后返回的状态码，默认返回503limit_conn_status 503; 然后在server{}里加上如下代码： 12#限制用户并发连接数为1limit_conn one 1;然后我们是使用ab测试来模拟并发请求：ab -n 5 -c 5 http://10.23.22.239/index.html 得到下面的结果，很明显并发被限制住了，超过阈值的都显示503： ![](并发限流设计/15700-20170501174045664-1757316734.png) 另外刚才是配置针对单个IP的并发限制，还是可以针对域名进行并发限制，配置和客户端IP类似。 1234#http&#123;&#125;段配置limit_conn_zone $ server_name zone=perserver:10m;#server&#123;&#125;段配置limit_conn perserver 1; ngx_http_limit_req_module 上面我们使用到了ngx_http_limit_conn_module 模块，来限制连接数。那么请求数的限制该怎么做呢？这就需要通过ngx_http_limit_req_module 模块来实现，该模块可以通过定义的键值来限制请求处理的频率。特别的，可以限制来自单个IP地址的请求处理频率。 限制的方法是使用了漏斗算法，每秒固定处理请求数，推迟过多请求。如果请求的频率超过了限制域配置的值，请求处理会被延迟或被丢弃，所以所有的请求都是以定义的频率被处理的。 在http{}中配置 #区域名称为one，大小为10m，平均处理的请求频率不能超过每秒一次。 1limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; 在server{}中配置 12#设置每个IP桶的数量为5limit_req zone=one burst=5; 上面设置定义了每个IP的请求处理只能限制在每秒1个。并且服务端可以为每个IP缓存5个请求，如果操作了5个请求，请求就会被丢弃。 使用ab测试模拟客户端连续访问10次：ab -n 10 -c 10 http://10.23.22.239/index.html 如下图，设置了桶的个数为5个。一共10个请求，第一个请求马上被处理。第2-6个被存放在桶中。由于桶满了，没有设置nodelay因此，余下的4个请求被丢弃。 ![](并发限流设计/15700-20170501174046554-1796027351.png)分布式限流实现-Reids可行性分析最快捷且有效的方式是使用RateLimiter实现，但是这很容易踩到一个坑，单节点模式下，使用RateLimiter进行限流一点问题都没有。但是…线上是分布式系统，布署了多个节点，而且多个节点最终调用的是同一个短信服务商接口。虽然我们对单个节点能做到将QPS限制在400/s，但是多节点条件下，如果每个节点均是400/s，那么到服务商那边的总请求就是节点数x400/s，于是限流效果失效。使用该方案对单节点的阈值控制是难以适应分布式环境的 Reids使用redis进行限流，其很好地解决了分布式环境下多实例所导致的并发问题。因为使用redis设置的计时器和计数器均是全局唯一的，不管多少个节点，它们使用的都是同样的计时器和计数器，因此可以做到非常精准的流控。同时，这种方案编码并不复杂，可能需要的代码不超过10行。 实施方案 根据可行性分析可知，整个系统采取redis限流处理是成本最低且最高效的。 具体实现 在Controller层设置两个全局key，一个用于计数，另一个用于计时 12private static final String API_WEB_TIME_KEY = \"time_key\";private static final String API_WEB_COUNTER_KEY = \"counter_key\"; 对时间key的存在与否进行判断，并对计数器是否超过阈值进行判断 1234567 if(!cacheDao.hasKey(API_WEB_TIME_KEY)) &#123; cacheDao.putToValue(API_WEB_TIME_KEY,0,(long)1, TimeUnit.SECONDS); cacheDao.putToValue(API_WEB_COUNTER_KEY,0,(long)2, TimeUnit.SECONDS);//时间到就重新初始化为 &#125;if(cacheDao.hasKey(API_WEB_TIME_KEY)&amp;&amp;cacheDao.incrBy(API_WEB_COUNTER_KEY,(long)1) &gt; (long)400) &#123; LOGGER.info(\"调用频率过快\"); &#125; 实施结果 可以达到非常精准的流控 遗留问题 没有考虑到多节点并发操作的问题，redis的操作没有考虑到多线程和多节点的相互覆盖行为。 解决方案 1234567891011String key = String.valueOf(System.currentTimeMillis() / 1000); if(redisService.setIfNotExist(key, Long.valueOf(\"0\"), 10))&#123; // ok &#125;else&#123; // key already exists if(redisService.incr(key, 10) &lt;= 400)&#123; // ok &#125;&#123; // too fast &#125; &#125; 其中setIfNotExist和incr都是原子操作（redis保证）","categories":[],"tags":[],"author":"guoleijie"},{"title":"区块链应用-健康医疗","slug":"区块链应用-健康医疗","date":"2017-12-15T07:50:11.000Z","updated":"2017-12-16T14:19:35.000Z","comments":true,"path":"2017/12/15/区块链应用-健康医疗/","link":"","permalink":"http://guoleijie.github.io/2017/12/15/区块链应用-健康医疗/","excerpt":"","text":"当今行业中，区块链，人工智能，大数据是非常火热的。2016年12月底，我开始从事区块链方向的研究。","categories":[],"tags":[],"author":"GuoLeijie"}]}