{"meta":{"title":"Just Do IT","subtitle":"一个30岁又起航的程序猿","description":"一个30岁又起航的程序猿","author":"GuoLeijie","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2017-10-20T08:19:30.000Z","updated":"2017-11-17T10:44:53.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"并发系统限流","slug":"并发限流设计","date":"2018-07-26T14:53:14.000Z","updated":"2018-08-08T21:11:18.000Z","comments":true,"path":"2018/07/26/并发限流设计/","link":"","permalink":"http://yoursite.com/2018/07/26/并发限流设计/","excerpt":"","text":"#谈谈高并发系统的限流 ##缓存缓存比较好理解，在大型高并发系统中，如果没有缓存数据库将分分钟被爆，系统也会瞬间瘫痪。使用缓存不单单能够提升系统访问速度、提高并发访问量，也是保护数据库、保护系统的有效方式。大型网站一般主要是“读”，缓存的使用很容易被想到。在大型“写”系统中，缓存也常常扮演者非常重要的角色。比如累积一些数据批量写入，内存里面的缓存队列（生产消费），以及HBase写数据的机制等等也都是通过缓存提升系统的吞吐量或者实现系统的保护措施。甚至消息中间件，你也可以认为是一种分布式的数据缓存。 ##降级服务降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。降级往往会指定不同的级别，面临不同的异常等级执行不同的处理。根据服务方式：可以拒接服务，可以延迟服务，也有时候可以随机服务。根据服务范围：可以砍掉某个功能，也可以砍掉某些模块。总之服务降级需要根据不同的业务需求采用不同的降级策略。主要的目的就是服务虽然有损但是总比没有好。 ##限流限流可以认为服务降级的一种，限流就是限制系统的输入和输出流量已达到保护系统的目的。一般来说系统的吞吐量是可以被测算的，为了保证系统的稳定运行，一旦达到的需要限制的阈值，就需要限制流量并采取一些措施以完成限制流量的目的。比如：延迟处理，拒绝处理，或者部分拒绝处理等等。 ##限流的算法常见的限流算法有：计数器、漏桶和令牌桶算法。 ###计数器计数器是最简单粗暴的算法。比如某个服务最多只能每秒钟处理100个请求。我们可以设置一个1秒钟的滑动窗口，窗口中有10个格子，每个格子100毫秒，每100毫秒移动一次，每次移动都需要记录当前服务请求的次数。内存中需要保存10次的次数。可以用数据结构LinkedList来实现。格子每次移动的时候判断一次，当前访问次数和LinkedList中最后一个相差是否超过100，如果超过就需要限流了。很明显，当滑动窗口的格子划分的越多，那么滑动窗口的滚动就越平滑，限流的统计就会越精确。示例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.LinkedList;import java.util.Random;import java.util.concurrent.atomic.AtomicLong;public class Counter &#123; /** * 服务访问次数，可以放在Redis中，实现分布式系统的访问计数 */ AtomicLong counter = new AtomicLong(); /** * 使用LinkedList来记录滑动窗口的10个格子。 */ LinkedList&lt;Long&gt; ll = new LinkedList&lt;&gt;(); public static void main(String[] args) &#123; Counter counter = new Counter(); counter.doCheck(); &#125; private void doCheck() &#123; Random random = new Random(); while (true) &#123; //每100毫秒随机增加20以下的请求量 counter.addAndGet(random.nextInt(20)); ll.addLast(counter.longValue()); if (ll.size() &gt; 10) &#123; ll.removeFirst(); &#125; //比较最后一个和第一个，两者相差一秒 System.out.println(\"ll.peekLast():\" + ll.peekLast() + \",ll.peekFirst():\" + ll.peekFirst()); if ((ll.peekLast() - ll.peekFirst()) &gt; 100) &#123; //To limit rate System.out.println(\"进入限流程序\"); &#125; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; ###漏桶算法漏桶算法即leaky bucket是一种非常常用的限流算法，可以用来实现流量整形（Traffic Shaping）和流量控制（Traffic Policing）。贴了一张维基百科上示意图帮助大家理解： 漏桶算法的主要概念如下： 一个固定容量的漏桶，按照常量固定速率流出水滴； 如果桶是空的，则不需流出水滴； 可以以任意速率流入水滴到漏桶； 如果流入水滴超出了桶的容量，则流入的水滴溢出了（被丢弃），而漏桶容量是不变的。 漏桶算法比较好实现，在单机系统中可以使用队列来实现（.Net中TPL DataFlow可以较好的处理类似的问题，你可以在这里找到相关的介绍），在分布式环境中消息中间件或者Redis都是可选的方案。 ###令牌桶算法令牌桶算法是一个存放固定容量令牌（token）的桶，按照固定速率往桶里添加令牌。令牌桶算法基本可以用下面的几个概念来描述： 令牌将按照固定的速率被放入令牌桶中。比如每秒放10个。 桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝。 当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上。 如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃，要么缓冲区等待）。如下图： 令牌算法是根据放令牌的速率去控制输出的速率，也就是上图的to network的速率。to network我们可以理解为消息的处理程序，执行某段业务或者调用某个RPC。 ###漏桶和令牌桶的比较 令牌桶可以在运行时控制和调整数据处理的速率，处理某时的突发流量。放令牌的频率增加可以提升整体数据处理的速度，而通过每次获取令牌的个数增加或者放慢令牌的发放速度和降低整体数据处理速度。而漏桶不行，因为它的流出速率是固定的，程序处理速度也是固定的。 整体而言，令牌桶算法更优，但是实现更为复杂一些。 ##限流算法实现 ###Guava Guava是一个Google开源项目，包含了若干被Google的Java项目广泛依赖的核心库，其中的RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。 常规速率： 创建一个限流器，设置每秒放置的令牌数：2个。返回的RateLimiter对象可以保证1秒内不会给超过2个令牌，并且是固定速率的放置。达到平滑输出的效果 1234567891011121314151617public void test()&#123; /** * 创建一个限流器，设置每秒放置的令牌数：2个。速率是每秒可以2个的消息。 * 返回的RateLimiter对象可以保证1秒内不会给超过2个令牌，并且是固定速率的放置。达到平滑输出的效果 */ RateLimiter r = RateLimiter.create(2); while (true) &#123; /** * acquire()获取一个令牌，并且返回这个获取这个令牌所需要的时间。如果桶里没有令牌则等待，直到有令牌。 * acquire(N)可以获取多个令牌。 */ System.out.println(r.acquire()); &#125;&#125; 上面代码执行的结果如下图，基本是0.5秒一个数据。拿到令牌后才能处理数据，达到输出数据或者调用接口的平滑效果。acquire()的返回值是等待令牌的时间，如果需要对某些突发的流量进行处理的话，可以对这个返回值设置一个阈值，根据不同的情况进行处理，比如过期丢弃。 突发流量： 突发流量可以是突发的多，也可以是突发的少。首先来看个突发多的例子。还是上面例子的流量，每秒2个数据令牌。如下代码使用acquire方法，指定参数。 System.out.println(r.acquire(2)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); 得到如下类似的输出。 如果要一次新处理更多的数据，则需要更多的令牌。代码首先获取2个令牌，那么下一个令牌就不是0.5秒之后获得了，还是1秒以后，之后又恢复常规速度。这是一个突发多的例子，如果是突发没有流量，如下代码： System.out.println(r.acquire(1)); Thread.sleep(2000); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); 得到如下类似的结果： 等了两秒钟之后，令牌桶里面就积累了3个令牌，可以连续不花时间的获取出来。处理突发其实也就是在单位时间内输出恒定。这两种方式都是使用的RateLimiter的子类SmoothBursty。另一个子类是SmoothWarmingUp，它提供的有一定缓冲的流量输出方案。 1234567891011121314151617/*** 创建一个限流器，设置每秒放置的令牌数：2个。速率是每秒可以210的消息。* 返回的RateLimiter对象可以保证1秒内不会给超过2个令牌，并且是固定速率的放置。达到平滑输出的效果* 设置缓冲时间为3秒*/RateLimiter r = RateLimiter.create(2,3,TimeUnit.SECONDS);while (true) &#123; /** * acquire()获取一个令牌，并且返回这个获取这个令牌所需要的时间。如果桶里没有令牌则等待，直到有令牌。 * acquire(N)可以获取多个令牌。 */ System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1)); System.out.println(r.acquire(1));&#125; 输出结果如下图，由于设置了缓冲的时间是3秒，令牌桶一开始并不会0.5秒给一个消息，而是形成一个平滑线性下降的坡度，频率越来越高，在3秒钟之内达到原本设置的频率，以后就以固定的频率输出。图中红线圈出来的3次累加起来正好是3秒左右。这种功能适合系统刚启动需要一点时间来“热身”的场景。 ![](并发限流设计/15700-20170501174044882-556744286.png ) ###Nginx 对于Nginx接入层限流可以使用Nginx自带了两个模块：连接数限流模块ngx_http_limit_conn_module和漏桶算法实现的请求限流模块ngx_http_limit_req_module。 ngx_http_limit_conn_module 我们经常会遇到这种情况，服务器流量异常，负载过大等等。对于大流量恶意的攻击访问，会带来带宽的浪费，服务器压力，影响业务，往往考虑对同一个ip的连接数，并发数进行限制。ngx_http_limit_conn_module 模块来实现该需求。该模块可以根据定义的键来限制每个键值的连接数，如同一个IP来源的连接数。并不是所有的连接都会被该模块计数，只有那些正在被处理的请求（这些请求的头信息已被完全读入）所在的连接才会被计数。 我们可以在nginx_conf的http{}中加上如下配置实现限制： 1234567#限制每个用户的并发连接数，取名onelimit_conn_zone $binary_remote_addr zone=one:10m;#配置记录被限流后的日志级别，默认error级别limit_conn_log_level error;#配置被限流后返回的状态码，默认返回503limit_conn_status 503; 然后在server{}里加上如下代码： 12#限制用户并发连接数为1limit_conn one 1; 然后我们是使用ab测试来模拟并发请求：ab -n 5 -c 5 http://10.23.22.239/index.html 得到下面的结果，很明显并发被限制住了，超过阈值的都显示503： ![](并发限流设计/15700-20170501174045664-1757316734.png) 另外刚才是配置针对单个IP的并发限制，还是可以针对域名进行并发限制，配置和客户端IP类似。 1234#http&#123;&#125;段配置limit_conn_zone $ server_name zone=perserver:10m;#server&#123;&#125;段配置limit_conn perserver 1; ngx_http_limit_req_module 上面我们使用到了ngx_http_limit_conn_module 模块，来限制连接数。那么请求数的限制该怎么做呢？这就需要通过ngx_http_limit_req_module 模块来实现，该模块可以通过定义的键值来限制请求处理的频率。特别的，可以限制来自单个IP地址的请求处理频率。 限制的方法是使用了漏斗算法，每秒固定处理请求数，推迟过多请求。如果请求的频率超过了限制域配置的值，请求处理会被延迟或被丢弃，所以所有的请求都是以定义的频率被处理的。 在http{}中配置 #区域名称为one，大小为10m，平均处理的请求频率不能超过每秒一次。 1limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; 在server{}中配置 12#设置每个IP桶的数量为5limit_req zone=one burst=5; 上面设置定义了每个IP的请求处理只能限制在每秒1个。并且服务端可以为每个IP缓存5个请求，如果操作了5个请求，请求就会被丢弃。 使用ab测试模拟客户端连续访问10次：ab -n 10 -c 10 http://10.23.22.239/index.html 如下图，设置了桶的个数为5个。一共10个请求，第一个请求马上被处理。第2-6个被存放在桶中。由于桶满了，没有设置nodelay因此，余下的4个请求被丢弃。 ![](并发限流设计/15700-20170501174046554-1796027351.png) ##分布式限流实现-Reids ###可行性分析最快捷且有效的方式是使用RateLimiter实现，但是这很容易踩到一个坑，单节点模式下，使用RateLimiter进行限流一点问题都没有。但是…线上是分布式系统，布署了多个节点，而且多个节点最终调用的是同一个短信服务商接口。虽然我们对单个节点能做到将QPS限制在400/s，但是多节点条件下，如果每个节点均是400/s，那么到服务商那边的总请求就是节点数x400/s，于是限流效果失效。使用该方案对单节点的阈值控制是难以适应分布式环境的 ###Reids使用redis进行限流，其很好地解决了分布式环境下多实例所导致的并发问题。因为使用redis设置的计时器和计数器均是全局唯一的，不管多少个节点，它们使用的都是同样的计时器和计数器，因此可以做到非常精准的流控。同时，这种方案编码并不复杂，可能需要的代码不超过10行。 实施方案 根据可行性分析可知，整个系统采取redis限流处理是成本最低且最高效的。 具体实现 在Controller层设置两个全局key，一个用于计数，另一个用于计时 12private static final String API_WEB_TIME_KEY = \"time_key\";private static final String API_WEB_COUNTER_KEY = \"counter_key\"; 对时间key的存在与否进行判断，并对计数器是否超过阈值进行判断 1234567 if(!cacheDao.hasKey(API_WEB_TIME_KEY)) &#123; cacheDao.putToValue(API_WEB_TIME_KEY,0,(long)1, TimeUnit.SECONDS); cacheDao.putToValue(API_WEB_COUNTER_KEY,0,(long)2, TimeUnit.SECONDS);//时间到就重新初始化为 &#125;if(cacheDao.hasKey(API_WEB_TIME_KEY)&amp;&amp;cacheDao.incrBy(API_WEB_COUNTER_KEY,(long)1) &gt; (long)400) &#123; LOGGER.info(\"调用频率过快\"); &#125; 实施结果 可以达到非常精准的流控 遗留问题 没有考虑到多节点并发操作的问题，redis的操作没有考虑到多线程和多节点的相互覆盖行为。 解决方案 1234567891011String key = String.valueOf(System.currentTimeMillis() / 1000); if(redisService.setIfNotExist(key, Long.valueOf(\"0\"), 10))&#123; // ok &#125;else&#123; // key already exists if(redisService.incr(key, 10) &lt;= 400)&#123; // ok &#125;&#123; // too fast &#125; &#125; 其中setIfNotExist和incr都是原子操作（redis保证）","categories":[],"tags":[]},{"title":"将自己的代码上传到maven中央库","slug":"将自己的代码上传到maven中央库","date":"2018-02-27T23:53:31.000Z","updated":"2018-02-27T23:58:43.000Z","comments":true,"path":"2018/02/28/将自己的代码上传到maven中央库/","link":"","permalink":"http://yoursite.com/2018/02/28/将自己的代码上传到maven中央库/","excerpt":"","text":"","categories":[{"name":"opensource","slug":"opensource","permalink":"http://yoursite.com/categories/opensource/"}],"tags":[],"author":"GuoLeijie"},{"title":"阿里Java代码规约插件","slug":"阿里Java代码规约插件","date":"2018-02-26T04:21:26.000Z","updated":"2018-02-26T04:26:52.000Z","comments":true,"path":"2018/02/26/阿里Java代码规约插件/","link":"","permalink":"http://yoursite.com/2018/02/26/阿里Java代码规约插件/","excerpt":"","text":"###概述 2017年10月14日杭州云栖大会，Java代码规约扫描插件全球首发仪式正式启动，规范正式以插件形式公开走向业界，引领Java语言的规范之路。目前，插件已在云效公有云产品中集成，立即体验！（云效&gt;公有云&gt;设置-&gt;测试服务-&gt;阿里巴巴Java代码规约）。 链接: 插件地址 ###开始安装 选择你开发的平台: eclipse 就选eclipse, idea 直接去idea的 插件搜索 alibaba 即可安装","categories":[],"tags":[],"author":"GuoLeijie"},{"title":"PM2 - 业界标准的任务执行器2","slug":"pm2","date":"2018-02-11T11:55:16.000Z","updated":"2018-07-21T11:53:29.000Z","comments":true,"path":"2018/02/11/pm2/","link":"","permalink":"http://yoursite.com/2018/02/11/pm2/","excerpt":"","text":"PM2 - 业界标准的任务执行器一. 命令 运行应用 1pm2 start helloworld.js pm2会注册一个名为helloworld的应用。这个应用运行在frok模式下，该模式下pm2不进行负载均衡，而是简单地fork该应用。 显示应用详细信息 1pm2 show 0 可以得到id为0的应用的相关信息。 监控pm2下运行的应用列表 1pm2 monit 查看应用日志信息 1pm2 logs 无缝重启应用 1pm2 reload all 这个命令可以确保应用能完成重启，并且无停机时间。pm2 会将请求放入队列，等待重启后的应用再次响应请求。 12//细粒度重启单个应用pm2 reload helloworld 多节点负载模式启动应用 1pm2 start helloworld.js -i 3 pm2充当控制主进程与3个工作进程之间的轮询调度器，因此可以并行处理3个请求。 增加、减少工作节点 1pm2 scale helloworld 2 工作节点由3个减少为2个。 二. PM2的编程接口 pm2”生态”系统文件生成 1pm2 ecosystem 该命令会生成一个ecosystem.json文件，文件中包含了pm2集群的骨架。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253module.exports = &#123; /** * Application configuration section * http://pm2.keymetrics.io/docs/usage/application-declaration/ */ apps : [ // First application &#123; name : 'API', script : 'app.js', env: &#123; COMMON_VARIABLE: 'true' &#125;, env_production : &#123; NODE_ENV: 'production' &#125; &#125;, // Second application &#123; name : 'WEB', script : 'web.js' &#125; ], /** * Deployment section * http://pm2.keymetrics.io/docs/usage/deployment/ */ deploy : &#123; production : &#123; user : 'node', host : '212.83.163.1', ref : 'origin/master', repo : 'git@github.com:repo.git', path : '/var/www/production', 'post-deploy' : 'npm install &amp;&amp; pm2 reload ecosystem.config.js --env production' &#125;, dev : &#123; user : 'node', host : '212.83.163.1', ref : 'origin/master', repo : 'git@github.com:repo.git', path : '/var/www/development', 'post-deploy' : 'npm install &amp;&amp; pm2 reload ecosystem.config.js --env dev', env : &#123; NODE_ENV: 'dev' &#125; &#125; &#125;&#125;; | 字段名 | 字段含义 | 示例 | | :-: | :-: | :-: | | name | 应用名称 | | | Script | 应用的启动脚本 | | | env | 由pm2注入系统的环境变量 | | | env_\\&lt;environment> | 在deploy键的配置下定义了两套环境 | Production,dev | 应用配置安装 1pm2 deploy ecosystem.json production setup 应用部署 1pm2 deploy ecosystem.json production","categories":[],"tags":[],"author":"GuoLeijie"},{"title":"区块链应用-健康医疗","slug":"区块链应用-健康医疗","date":"2017-12-15T07:50:11.000Z","updated":"2017-12-16T14:19:35.000Z","comments":true,"path":"2017/12/15/区块链应用-健康医疗/","link":"","permalink":"http://yoursite.com/2017/12/15/区块链应用-健康医疗/","excerpt":"","text":"当今行业中，区块链，人工智能，大数据是非常火热的。2016年12月底，我开始从事区块链方向的研究。","categories":[],"tags":[],"author":"GuoLeijie"},{"title":"Spring JDBC详解","slug":"Spring-JDBC详解","date":"2017-09-27T01:51:11.000Z","updated":"2017-11-17T10:44:53.000Z","comments":true,"path":"2017/09/27/Spring-JDBC详解/","link":"","permalink":"http://yoursite.com/2017/09/27/Spring-JDBC详解/","excerpt":"","text":"#Spring JDBC详解 《Spring JDBC详解》本文旨在讲述Spring JDBC模块的用法。Spring JDBC模块是Spring框架的基础模块之一。 一、概述在Spring JDBC模块中，所有的类可以被分到四个单独的包： core即核心包，它包含了JDBC的核心功能。此包内有很多重要的类，包括：JdbcTemplate类、SimpleJdbcInsert类，SimpleJdbcCall类，以及NamedParameterJdbcTemplate类。 datasource即数据源包，访问数据源的实用工具类。它有多种数据源的实现，可以在JavaEE容器外部测试JDBC代码。 object即对象包，以面向对象的方式访问数据库。它允许执行查询并返回结果作为业务对象。它可以在数据表的列和业务对象的属性之间映射查询结果。 support即支持包，是core包和object包的支持类。例如提供了异常转换功能的SQLException类。 ##二、配置下面我们以MySQL数据库为例，开始简单的数据源配置：123456789101112131415@Configuration@ComponentScan(\"com.ch.myalbumjdbc\")public class SpringJdbcConfig &#123; @Bean public DataSource mysqlDataSource() &#123; DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUrl(\"jdbc:mysql://localhost:3306/springjdbc\"); dataSource.setUsername(\"guest_user\"); dataSource.setPassword(\"guest_password\"); return dataSource; &#125;&#125; 或者，您还可以利用嵌入式数据库进行开发或测试，比如用HSQL嵌入式数据库进行快速配置并创建实例： 1234567@Beanpublic DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.HSQL) .addScript(\"classpath:jdbc/schema.sql\") .addScript(\"classpath:jdbc/test-data.sql\").build();&#125; 最后，也可以使用XML配置来实现前面的注释配置的效果： 1234567&lt;bean id=\"dataSource\" class=\"org.apache.commons.dbcp.BasicDataSource\" destroy-method=\"close\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/springjdbc\"/&gt; &lt;property name=\"username\" value=\"guest_user\"/&gt; &lt;property name=\"password\" value=\"guest_password\"/&gt;&lt;/bean&gt; ##三、JdbcTemplate的使用和运行查询 基本的查询JDBC模板是Spring JDBC模块中主要的API，它提供了常见的数据库访问功能：1int result = jdbcTemplate.queryForObject(\"SELECT COUNT(*) FROM EMPLOYEE\", Integer.class); 下面是简单的插入功能：123public int addEmplyee(int id) &#123; return jdbcTemplate.update(\"INSERT INTO EMPLOYEE VALUES (?, ?, ?, ?)\", 5, \"Bill\", \"Gates\", \"USA\");&#125; 注意提供参数的标准语法——使用“？”字符。下面，让我们看看替代语法。 查询与命名参数要获得命名参数的支持，我们需要使用Spring JDBC提供的其它JDBC模板——NamedParameterJdbcTemplate。此类封装了JbdcTemplate，并提供了使用“？”来替代指定参数的传统语法。它使用传递的参数来替换占位符“？”，以执行传参的查询：123SqlParameterSource namedParameters = new MapSqlParameterSource().addValue(\"id\", 1);return namedParameterJdbcTemplate.queryForObject( \"SELECT FIRST_NAME FROM EMPLOYEE WHERE ID = :id\", namedParameters, String.class); 请注意，我们使用的是MapSqlParameterSource来提供值的命名参数。下面是使用bean类的属性来确定命名参数简单例子 1234567Employee employee = new Employee();employee.setFirstName(\"James\");String SELECT_BY_ID = \"SELECT COUNT(*) FROM EMPLOYEE WHERE FIRST_NAME = :firstName\";SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(employee);return namedParameterJdbcTemplate.queryForObject(SELECT_BY_ID, namedParameters, Integer.class); 请注意，我们是怎样利用BeanPropertySqlParameterSource的实现来替代指定的命名参数。 把查询结果映射到java对象还有一个非常有用的功能是把查询结果映射到Java对象——通过实现RowMapper接口。例如，对于查询返回的每一行结果，Spring会使用该行映射来填充Java bean123456789101112131415public class EmployeeRowMapper implements RowMapper&lt;Employee&gt; &#123; @Override public Employee mapRow(ResultSet rs, int rowNum) throws SQLException &#123; Employee employee = new Employee(); employee.setId(rs.getInt(\"ID\")); employee.setFirstName(rs.getString(\"FIRST_NAME\")); employee.setLastName(rs.getString(\"LAST_NAME\")); employee.setAddress(rs.getString(\"ADDRESS\")); return employee; &#125;&#125;","categories":[],"tags":[],"author":"GuoLeijie"},{"title":"JVM调优之六 - 找到长时间占用cpu的线程所在程序","slug":"JVM调优之六-找到长时间占用cpu的线程所在程序","date":"2017-09-27T01:51:11.000Z","updated":"2018-07-20T16:06:23.000Z","comments":true,"path":"2017/09/27/JVM调优之六-找到长时间占用cpu的线程所在程序/","link":"","permalink":"http://yoursite.com/2017/09/27/JVM调优之六-找到长时间占用cpu的线程所在程序/","excerpt":"","text":"jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。 首先确定进程的 ID ，可以使用 jps -v 或者 top 命令直接查看 1ps -ef | grep mule 查看该进程中哪个线程占用大量 CPU，执行 top -Hp [PID] 结果如下： 可以发现编号为 350xx 的共有 9 个线程占用了 100% 的 CPU，好，接下来咱们随便取一个线程 ID ，假设我们想看编号为 35053 这个线程。 首先将 35053 转成 16 进制是 88ED （可以用在线工具转换)也可以使用linux命令行工具1printf \"%x\\n\" 21742 得到21742的十六进制值为54ee，下面会用到。 OK，下一步终于轮到jstack上场了，它用来输出进程21711的堆栈信息，然后根据线程ID的十六进制值grep，如下： 12root@ubuntu:/# jstack 21711 | grep 54ee\"PollIntervalRetrySchedulerThread\" prio=10 tid=0x00007f950043e000 nid=0x54ee in Object.wait() 可以看到CPU消耗在PollIntervalRetrySchedulerThread这个类的Object.wait()，我找了下我的代码，定位到下面的代码： 123456789101112131415// Idle waitgetLog().info(\"Thread [\" + getName() + \"] is idle waiting...\");schedulerThreadState = PollTaskSchedulerThreadState.IdleWaiting;long now = System.currentTimeMillis();long waitTime = now + getIdleWaitTime();long timeUntilContinue = waitTime - now;synchronized(sigLock) &#123; try &#123; if(!halted.get()) &#123; sigLock.wait(timeUntilContinue); &#125; &#125; catch (InterruptedException ignore) &#123; &#125;&#125; 它是轮询任务的空闲等待代码，上面的sigLock.wait(timeUntilContinue)就对应了前面的Object.wait()。 本人已经试验过，就是这么查找线程","categories":[],"tags":[{"name":"JVM调优","slug":"JVM调优","permalink":"http://yoursite.com/tags/JVM调优/"}],"author":"GuoLeijie"},{"title":"Java使用RSA加密解密及签名校验","slug":"Java使用RSA加密解密及签名校验","date":"2017-02-27T23:53:31.000Z","updated":"2018-04-05T03:30:09.000Z","comments":true,"path":"2017/02/28/Java使用RSA加密解密及签名校验/","link":"","permalink":"http://yoursite.com/2017/02/28/Java使用RSA加密解密及签名校验/","excerpt":"","text":"该工具类中用到了BASE64，需要借助第三方类库：javabase64-1.3.1.jar 注意： RSA加密明文最大长度117字节，解密要求密文最大长度为128字节，所以在加密和解密的过程中需要分块进行。 RSA加密对明文的长度是有限制的，如果加密数据过大会抛出如下异常： 1234Exception in thread \"main\" javax.crypto.IllegalBlockSizeException: Data must not be longer than 117 bytes at com.sun.crypto.provider.RSACipher.a(DashoA13*..) at com.sun.crypto.provider.RSACipher.engineDoFinal(DashoA13*..) at javax.crypto.Cipher.doFinal(DashoA13*..) RSAUtils.java–RSA公钥/私钥/签名工具包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323package com.ljq.test;import java.io.ByteArrayOutputStream;import java.security.Key;import java.security.KeyFactory;import java.security.KeyPair;import java.security.KeyPairGenerator;import java.security.PrivateKey;import java.security.PublicKey;import java.security.Signature;import java.security.interfaces.RSAPrivateKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;import java.util.HashMap;import java.util.Map;import javax.crypto.Cipher;/** * &lt;p&gt; * RSA公钥/私钥/签名工具包 * &lt;/p&gt; * &lt;p&gt; * 罗纳德·李维斯特（Ron [R]ivest）、阿迪·萨莫尔（Adi [S]hamir）和伦纳德·阿德曼（Leonard [A]dleman） * &lt;/p&gt; * &lt;p&gt; * 字符串格式的密钥在未在特殊说明情况下都为BASE64编码格式&lt;br/&gt; * 由于非对称加密速度极其缓慢，一般文件不使用它来加密而是使用对称加密，&lt;br/&gt; * 非对称加密算法可以用来对对称加密的密钥加密，这样保证密钥的安全也就保证了数据的安全 * &lt;/p&gt; * * @author IceWee * @date 2012-4-26 * @version 1.0 */public class RSAUtils &#123; /** * 加密算法RSA */ public static final String KEY_ALGORITHM = \"RSA\"; /** * 签名算法 */ public static final String SIGNATURE_ALGORITHM = \"MD5withRSA\"; /** * 获取公钥的key */ private static final String PUBLIC_KEY = \"RSAPublicKey\"; /** * 获取私钥的key */ private static final String PRIVATE_KEY = \"RSAPrivateKey\"; /** * RSA最大加密明文大小 */ private static final int MAX_ENCRYPT_BLOCK = 117; /** * RSA最大解密密文大小 */ private static final int MAX_DECRYPT_BLOCK = 128; /** * &lt;p&gt; * 生成密钥对(公钥和私钥) * &lt;/p&gt; * * @return * @throws Exception */ public static Map&lt;String, Object&gt; genKeyPair() throws Exception &#123; KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(KEY_ALGORITHM); keyPairGen.initialize(1024); KeyPair keyPair = keyPairGen.generateKeyPair(); RSAPublicKey publicKey = (RSAPublicKey) keyPair.getPublic(); RSAPrivateKey privateKey = (RSAPrivateKey) keyPair.getPrivate(); Map&lt;String, Object&gt; keyMap = new HashMap&lt;String, Object&gt;(2); keyMap.put(PUBLIC_KEY, publicKey); keyMap.put(PRIVATE_KEY, privateKey); return keyMap; &#125; /** * &lt;p&gt; * 用私钥对信息生成数字签名 * &lt;/p&gt; * * @param data 已加密数据 * @param privateKey 私钥(BASE64编码) * * @return * @throws Exception */ public static String sign(byte[] data, String privateKey) throws Exception &#123; byte[] keyBytes = Base64Utils.decode(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PrivateKey privateK = keyFactory.generatePrivate(pkcs8KeySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initSign(privateK); signature.update(data); return Base64Utils.encode(signature.sign()); &#125; /** * &lt;p&gt; * 校验数字签名 * &lt;/p&gt; * * @param data 已加密数据 * @param publicKey 公钥(BASE64编码) * @param sign 数字签名 * * @return * @throws Exception * */ public static boolean verify(byte[] data, String publicKey, String sign) throws Exception &#123; byte[] keyBytes = Base64Utils.decode(publicKey); X509EncodedKeySpec keySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); PublicKey publicK = keyFactory.generatePublic(keySpec); Signature signature = Signature.getInstance(SIGNATURE_ALGORITHM); signature.initVerify(publicK); signature.update(data); return signature.verify(Base64Utils.decode(sign)); &#125; /** * &lt;P&gt; * 私钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] decryptByPrivateKey(byte[] encryptedData, String privateKey) throws Exception &#123; byte[] keyBytes = Base64Utils.decode(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, privateK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; /** * &lt;p&gt; * 公钥解密 * &lt;/p&gt; * * @param encryptedData 已加密数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */ public static byte[] decryptByPublicKey(byte[] encryptedData, String publicKey) throws Exception &#123; byte[] keyBytes = Base64Utils.decode(publicKey); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.DECRYPT_MODE, publicK); int inputLen = encryptedData.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段解密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_DECRYPT_BLOCK) &#123; cache = cipher.doFinal(encryptedData, offSet, MAX_DECRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_DECRYPT_BLOCK; &#125; byte[] decryptedData = out.toByteArray(); out.close(); return decryptedData; &#125; /** * &lt;p&gt; * 公钥加密 * &lt;/p&gt; * * @param data 源数据 * @param publicKey 公钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPublicKey(byte[] data, String publicKey) throws Exception &#123; byte[] keyBytes = Base64Utils.decode(publicKey); X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key publicK = keyFactory.generatePublic(x509KeySpec); // 对数据加密 Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, publicK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; &#125; /** * &lt;p&gt; * 私钥加密 * &lt;/p&gt; * * @param data 源数据 * @param privateKey 私钥(BASE64编码) * @return * @throws Exception */ public static byte[] encryptByPrivateKey(byte[] data, String privateKey) throws Exception &#123; byte[] keyBytes = Base64Utils.decode(privateKey); PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(keyBytes); KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM); Key privateK = keyFactory.generatePrivate(pkcs8KeySpec); Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm()); cipher.init(Cipher.ENCRYPT_MODE, privateK); int inputLen = data.length; ByteArrayOutputStream out = new ByteArrayOutputStream(); int offSet = 0; byte[] cache; int i = 0; // 对数据分段加密 while (inputLen - offSet &gt; 0) &#123; if (inputLen - offSet &gt; MAX_ENCRYPT_BLOCK) &#123; cache = cipher.doFinal(data, offSet, MAX_ENCRYPT_BLOCK); &#125; else &#123; cache = cipher.doFinal(data, offSet, inputLen - offSet); &#125; out.write(cache, 0, cache.length); i++; offSet = i * MAX_ENCRYPT_BLOCK; &#125; byte[] encryptedData = out.toByteArray(); out.close(); return encryptedData; &#125; /** * &lt;p&gt; * 获取私钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return * @throws Exception */ public static String getPrivateKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PRIVATE_KEY); return Base64Utils.encode(key.getEncoded()); &#125; /** * &lt;p&gt; * 获取公钥 * &lt;/p&gt; * * @param keyMap 密钥对 * @return * @throws Exception */ public static String getPublicKey(Map&lt;String, Object&gt; keyMap) throws Exception &#123; Key key = (Key) keyMap.get(PUBLIC_KEY); return Base64Utils.encode(key.getEncoded()); &#125;&#125; Base64Utils.java–BASE64编码解码工具包 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149package com.ljq.test;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import it.sauronsoftware.base64.Base64;/** * &lt;p&gt; * BASE64编码解码工具包 * &lt;/p&gt; * &lt;p&gt; * 依赖javabase64-1.3.1.jar * &lt;/p&gt; * * @author IceWee * @date 2012-5-19 * @version 1.0 */public class Base64Utils &#123; /** * 文件读取缓冲区大小 */ private static final int CACHE_SIZE = 1024; /** * &lt;p&gt; * BASE64字符串解码为二进制数据 * &lt;/p&gt; * * @param base64 * @return * @throws Exception */ public static byte[] decode(String base64) throws Exception &#123; return Base64.decode(base64.getBytes()); &#125; /** * &lt;p&gt; * 二进制数据编码为BASE64字符串 * &lt;/p&gt; * * @param bytes * @return * @throws Exception */ public static String encode(byte[] bytes) throws Exception &#123; return new String(Base64.encode(bytes)); &#125; /** * &lt;p&gt; * 将文件编码为BASE64字符串 * &lt;/p&gt; * &lt;p&gt; * 大文件慎用，可能会导致内存溢出 * &lt;/p&gt; * * @param filePath * 文件绝对路径 * @return * @throws Exception */ public static String encodeFile(String filePath) throws Exception &#123; byte[] bytes = fileToByte(filePath); return encode(bytes); &#125; /** * &lt;p&gt; * BASE64字符串转回文件 * &lt;/p&gt; * * @param filePath * 文件绝对路径 * @param base64 * 编码字符串 * @throws Exception */ public static void decodeToFile(String filePath, String base64) throws Exception &#123; byte[] bytes = decode(base64); byteArrayToFile(bytes, filePath); &#125; /** * &lt;p&gt; * 文件转换为二进制数组 * &lt;/p&gt; * * @param filePath * 文件路径 * @return * @throws Exception */ public static byte[] fileToByte(String filePath) throws Exception &#123; byte[] data = new byte[0]; File file = new File(filePath); if (file.exists()) &#123; FileInputStream in = new FileInputStream(file); ByteArrayOutputStream out = new ByteArrayOutputStream(2048); byte[] cache = new byte[CACHE_SIZE]; int nRead = 0; while ((nRead = in.read(cache)) != -1) &#123; out.write(cache, 0, nRead); out.flush(); &#125; out.close(); in.close(); data = out.toByteArray(); &#125; return data; &#125; /** * &lt;p&gt; * 二进制数据写文件 * &lt;/p&gt; * * @param bytes * 二进制数据 * @param filePath * 文件生成目录 */ public static void byteArrayToFile(byte[] bytes, String filePath) throws Exception &#123; InputStream in = new ByteArrayInputStream(bytes); File destFile = new File(filePath); if (!destFile.getParentFile().exists()) &#123; destFile.getParentFile().mkdirs(); &#125; destFile.createNewFile(); OutputStream out = new FileOutputStream(destFile); byte[] cache = new byte[CACHE_SIZE]; int nRead = 0; while ((nRead = in.read(cache)) != -1) &#123; out.write(cache, 0, nRead); out.flush(); &#125; out.close(); in.close(); &#125;&#125; RSATester.java–测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.ljq.test;import java.util.Map;public class RSATester &#123; static String publicKey; static String privateKey; static &#123; try &#123; Map&lt;String, Object&gt; keyMap = RSAUtils.genKeyPair(); publicKey = RSAUtils.getPublicKey(keyMap); privateKey = RSAUtils.getPrivateKey(keyMap); System.err.println(\"公钥: \\n\\r\" + publicKey); System.err.println(\"私钥： \\n\\r\" + privateKey); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) throws Exception &#123; test(); testSign(); testHttpSign(); &#125; static void test() throws Exception &#123; System.err.println(\"公钥加密——私钥解密\"); String source = \"这是一行没有任何意义的文字，你看完了等于没看，不是吗？\"; System.out.println(\"\\r加密前文字：\\r\\n\" + source); byte[] data = source.getBytes(); byte[] encodedData = RSAUtils.encryptByPublicKey(data, publicKey); System.out.println(\"加密后文字：\\r\\n\" + new String(encodedData)); byte[] decodedData = RSAUtils.decryptByPrivateKey(encodedData, privateKey); String target = new String(decodedData); System.out.println(\"解密后文字: \\r\\n\" + target); &#125; static void testSign() throws Exception &#123; System.err.println(\"私钥加密——公钥解密\"); String source = \"这是一行测试RSA数字签名的无意义文字\"; System.out.println(\"原文字：\\r\\n\" + source); byte[] data = source.getBytes(); byte[] encodedData = RSAUtils.encryptByPrivateKey(data, privateKey); System.out.println(\"加密后：\\r\\n\" + new String(encodedData)); byte[] decodedData = RSAUtils.decryptByPublicKey(encodedData, publicKey); String target = new String(decodedData); System.out.println(\"解密后: \\r\\n\" + target); System.err.println(\"私钥签名——公钥验证签名\"); String sign = RSAUtils.sign(encodedData, privateKey); System.err.println(\"签名:\\r\" + sign); boolean status = RSAUtils.verify(encodedData, publicKey, sign); System.err.println(\"验证结果:\\r\" + status); &#125; static void testHttpSign() throws Exception &#123; String param = \"id=1&amp;name=张三\"; byte[] encodedData = RSAUtils.encryptByPrivateKey(param.getBytes(), privateKey); System.out.println(\"加密后：\" + encodedData); byte[] decodedData = RSAUtils.decryptByPublicKey(encodedData, publicKey); System.out.println(\"解密后：\" + new String(decodedData)); String sign = RSAUtils.sign(encodedData, privateKey); System.err.println(\"签名：\" + sign); boolean status = RSAUtils.verify(encodedData, publicKey, sign); System.err.println(\"签名验证结果：\" + status); &#125; &#125;","categories":[{"name":"算法及数据结构","slug":"算法及数据结构","permalink":"http://yoursite.com/categories/算法及数据结构/"}],"tags":[],"author":"Guoleijie"}]}